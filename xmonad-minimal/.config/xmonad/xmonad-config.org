#+TITLE: XMonad Configuration
#+AUTHOR: Yusef Aslam
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+PROPERTY: header-args :tangle xmonad.hs
#+auto_tangle: t
#+STARTUP: overview

* DONE Add tiled window dragging

* GHC LANGUAGE options
These are options for the GHC compiler to use.
#+begin_src haskell
-- vim: tabstop=2 shiftwidth=2 expandtab
  {-# LANGUAGE TypeSynonymInstances #-}
  {-# LANGUAGE MultiParamTypeClasses #-}
#+end_src

* Imports
** XMonad haskell library
#+begin_src haskell
import XMonad
#+end_src

** Window stack operation
#+begin_src haskell
import qualified XMonad.StackSet as W
#+end_src

** Hooks
#+begin_src haskell
import XMonad.Hooks.ManageHelpers
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.EwmhDesktops
import XMonad.Hooks.StatusBar
import XMonad.Hooks.StatusBar.PP
import XMonad.Hooks.DynamicIcons
#+end_src

** Utilities
#+begin_src haskell
import XMonad.Util.EZConfig
import qualified XMonad.Util.ExtensibleState as XS
import XMonad.Util.Loggers
#+end_src

** Actions
#+begin_src haskell
import XMonad.Actions.TiledWindowDragging
#+end_src

** Layouts
#+begin_src haskell
import XMonad.Layout.MultiToggle
import XMonad.Layout.MultiToggle.Instances
import XMonad.Layout.Renamed
import XMonad.Layout.DraggingVisualizer
#+end_src

** Misc
#+begin_src haskell
import qualified Data.Set as S
import qualified Data.Map as M
import Data.Foldable (for_)
import Data.Functor
#+end_src

* AppIcon configuration
These are icons for applications that are shown in XMobar next to the workspace number.
#+begin_src haskell
myIcons :: Query [String]
myIcons = composeAll
  [ className =? "Chromium" --> appIcon "\xf268"
  , className =? "steam" --> appIcon "\xf04d3"
  , className =? "Pavucontrol" --> appIcon "\xf04c3"
  , className =? "XTerm" --> appIcon "\xf489"
  , className =? "Emacs" --> appIcon "\xe632"
  , className =? "Vmware" --> appIcon "\xea7a"
  , className =? "qpwgraph" --> appIcon "\xf07e5"
  ]

myIconConfig :: IconConfig
myIconConfig = def { iconConfigIcons = myIcons
                   , iconConfigFmt = iconsFmtAppend unwords }
#+end_src

* Status bar configuration
#+begin_src haskell
mySB = statusBarProp "xmobar" (dynamicIconsPP myIconConfig myPP)

myPP :: PP
myPP = def { ppCurrent = xmobarColor "yellow" "" . wrap "[" " ]"
           , ppTitle   = xmobarColor "green" "" . shorten 40
           , ppVisible = wrap "(" ")"
           , ppUrgent  = xmobarColor "red" "yellow"
           , ppExtras  = [logTitles formatFocused formatUnfocused]
           , ppOrder   = \(ws:l:t:e) -> [ws, l] ++ e
           }
          where
            formatFocused = wrap "[" "]" . xmobarColor "#ff79c6" "" . shorten 50 . xmobarStrip
            formatUnfocused = wrap "(" ")" . xmobarColor "#bd93f9" "" . shorten 30 . xmobarStrip
#+end_src

* Main block
#+begin_src haskell
main :: IO ()
main = xmonad . docks . ewmhFullscreen . ewmh $ withEasySB mySB defToggleStrutsKey def
          { modMask = mod1Mask
          , terminal = "xterm"
          , borderWidth = 2
          , manageHook = myManageHook
          , layoutHook = myLayoutHook
          , logHook = raiseSaved
          , XMonad.mouseBindings = Main.mouseBindings
          }
#+end_src

* Keybinds
#+begin_src haskell
          `additionalKeysP`
          [ ("M-p", spawn "dmenu_run -fn 'DejaVu Sans Mono:pixelsize=18' -nf 'gray' -nb 'black' -sb 'red' -sf 'white'")
          , ("M-f", sendMessage $ Toggle Main.FULL)
          , ("<XF86AudioRaiseVolume>", spawn "pamixer -i2" )
          , ("<XF86AudioLowerVolume>", spawn "pamixer -d2" )
          , ("<XF86AudioMute>", spawn "pamixer -t" ) ]
#+end_src

** Mouse keybinds
#+begin_src haskell
-- | Mouse bindings: default actions bound to mouse events
-- | (Taken from XMonad source)
mouseBindings :: XConfig Layout -> M.Map (KeyMask, Button) (Window -> X ())
mouseBindings (XConfig {XMonad.modMask = modMask}) = M.fromList
    -- mod-button1 %! Set the window to floating mode and move by dragging
    [ ((modMask, button1), \w -> focus w >> mouseMoveWindow w
                                          >> windows W.shiftMaster)
    , ((modMask .|. shiftMask, button1), dragWindow)
    -- mod-button2 %! Raise the window to the top of the stack
    , ((modMask, button2), windows . (W.shiftMaster .) . W.focusWindow)
    -- mod-button3 %! Set the window to floating mode and resize by dragging
    , ((modMask, button3), \w -> focus w >> mouseResizeWindow w
                                         >> windows W.shiftMaster)
    -- you may also bind events to the mouse scroll wheel (button4 and button5)
    , ((modMask, button4), \w -> focus w >> windows W.swapUp)
    , ((modMask, button5), \w -> focus w >> windows W.swapDown)
    -- , ((modMask, button8), \w -> focus w >> windows W.focusUp
    --                                      >> updPointer)
    -- , ((modMask, button9), \w -> focus w >> windows W.focusDown
    --                                      >> updPointer)
    ]
#+end_src

* Misc
** iconPath function
+ This function is used to make specifiying icons for layouts or transformers easier because I don't have to specify an entire path everytime.
#+begin_src haskell
iconPath a = "<icon=/home/yaslam/.config/xmobar/icons/" ++ a ++ "/>"
#+end_src
** Slightly modified layout transformer
+ This is a layout transformer that I took from the [[https://hackage.haskell.org/package/xmonad-contrib-0.17.1/docs/src/XMonad.Layout.MultiToggle.Instances.html#StdTransformers][XMonad-Contrib source code]] and edited slightly to change the name into an icon. A layout transformer is a layout that you can dynamically apply to any layout that you are using in XMonad, like for example, you press Alt-f for a temporary fullscreen layout transformer on the current window.
#+begin_src haskell
data StdTransformers = FULL          -- ^ switch to Full layout
  deriving (Read, Show, Eq)

instance Transformer Main.StdTransformers Window where
    transform Main.FULL         x k = k (renamed [Replace $ iconPath "layout-full.xbm"] Full) (const x)
#+end_src

* Layouthook
Each layouts name has been replaced with an icon using the [[*iconPath function][iconPath function]] and the renamed module from XMonad-Contrib.
- These layouts are mostly the default XMonad layouts.
#+begin_src haskell
myLayoutHook = mkToggle (Main.FULL ?? EOT)
               $ avoidStruts
               $ draggingVisualizer
               (tiled ||| mtiled ||| full)
  where
     -- default tiling algorithm partitions the screen into two panes
     tiled   = renamed [Replace $ iconPath "layout-tiled.xbm"] $ Tall nmaster delta ratio

     mtiled   = renamed [Replace $ iconPath "layout-mtiled.xbm"] $ Mirror tiled

     full = renamed [Replace $ iconPath "layout-full.xbm"] $ Full

     -- The default number of windows in the master pane
     nmaster = 1

     -- Default proportion of screen occupied by master pane
     ratio   = 1/2

     -- Percent of screen to increment by when resizing panes
     delta   = 3/100
#+end_src

* Misc
The 5 blocks of code below basically let me spawn a window that is fully ignored by XMonad (won't get focused, can't be moved etc..), and it is perfect for a program like xeyes which you can use like a dock with this code.
#+begin_src haskell
-- provided by geekosaur on IRC
data SavedWindow = SavedWindow (S.Set Window) deriving (Read, Show)

-- provided by geekosaur on IRC
instance ExtensionClass SavedWindow where
  initialValue = SavedWindow S.empty
  extensionType = PersistentExtension

-- use in ManageHook: className =? "whatever" --> saveWindow
-- provided by geekosaur on IRC
saveWindow :: ManageHook
saveWindow = ask >>= \w -> liftX (XS.modify (\(SavedWindow s) -> SavedWindow (S.insert w s))) >> doIgnore

-- use in logHook: no parameters
-- provided by geekosaur on IRC
raiseSaved :: X ()
raiseSaved = do
  SavedWindow s <- XS.get
  withDisplay $ \d -> for_ s $ io . raiseWindow d

-- this lets you have a floating window that is fully ignored
-- but also lets you control the placement of the ignored floating window
-- thanks to [Leary] on #xmonad for this
-- use like: mapAt (Rectangle x y w h) <> doIgnore
-- in the manageHook
mapAt :: Rectangle -> ManageHook
mapAt r = ask >>= \w -> liftX (tileWindow w r $> mempty)
#+end_src

* Managehook
This is where you specify how windows will be shown by XMonad (e.g: the workspace it will be shown on, whether it's floating or tiled etc..)
#+begin_src haskell
myManageHook :: ManageHook
myManageHook = composeAll $
               [ className =? "XClock" --> mapAt (Rectangle 1760 30 150 150) <> saveWindow
               , className =? "XEyes" --> mapAt (Rectangle 1860 1020 60 60) <> saveWindow ]

#+end_src
